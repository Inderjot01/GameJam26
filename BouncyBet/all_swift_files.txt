//
//  DataModels.swift
//  BouncyBet
//
//  Defines all pure data structures for the game.
//

import Foundation
import CoreGraphics // For CGVector

// MARK: - Player State

/// Holds all persistent data for the player.
/// Codable allows it to be saved to UserDefaults easily.
struct PlayerState: Codable {
    var coins: Int
    var highScore: Int

    /// Provides a default state for new players.
    static var `default`: PlayerState {
        PlayerState(coins: 100, highScore: 0)
    }
}

// MARK: - Game Configuration

/// Contains static constants for game balancing and physics.
/// Centralizing these here makes the game easy to tune.
struct GameConfig {
    static let projectileLifespan: TimeInterval = 10.0
    
    // Wager and Payout
    static let wagerAmount: Int = 10
    static let payoutMultiplier: Int = 1 // Payout = Score * Multiplier
    
    // Scoring - Balanced for fair gameplay
    static let obstaclePoints: Int = 5      // Reduced from 10
    static let rewardPoints: Int = 50       // Reduced from 100
    static let hazardPoints: Int = -50      // Same penalty
}

// MARK: - Field Object Definitions

/// Defines the type of object on the field.
enum ObjectType: CaseIterable {
    case obstacle // Standard peg
    case reward   // Positive points
    case hazard   // Negative points
}

/// A pure data model representing a single object in the field.
struct ObjectData {
    let id: UUID = UUID()
    let type: ObjectType
    let points: Int
    let textureName: String
    
    /// Factory method to create a random object with balanced distribution
    static func createRandom() -> ObjectData {
        let random = Int.random(in: 0..<100)
        
        if random < 50 {
            // 50% chance for obstacles
            return ObjectData(type: .obstacle, points: GameConfig.obstaclePoints, textureName: "obstacle")
        } else if random < 80 {
            // 30% chance for rewards
            return ObjectData(type: .reward, points: GameConfig.rewardPoints, textureName: "reward")
        } else {
            // 20% chance for hazards
            return ObjectData(type: .hazard, points: GameConfig.hazardPoints, textureName: "hazard")
        }
    }
}

// MARK: - Physics Categories

/// Defines all physics categories using UInt32 bitmasks.
/// This struct is the brain of the collision detection system.
struct PhysicsCategory {
    static let none:            UInt32 = 0
    static let projectile:      UInt32 = 0x1 << 0 // (1)
    static let obstacle:        UInt32 = 0x1 << 1 // (2)
    static let reward:          UInt32 = 0x1 << 2 // (4)
    static let hazard:          UInt32 = 0x1 << 3 // (8)
    static let worldBoundary:   UInt32 = 0x1 << 4 // (16)
}
//
//
//  BouncyBetGameApp.swift
//  BouncyBet
//
//  This is the main entry point for the SwiftUI application.
//

import SwiftUI

@main
struct BouncyBetGameApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
//
//  PersistenceManager.swift
//  BouncyBet
//
//  Manages saving and loading game data (PlayerState).
//  Uses a Singleton pattern and a @UserDefault property wrapper.
//

import Foundation

/// A singleton class to manage all data persistence.
class PersistenceManager {
    static let shared = PersistenceManager()
    
    // This property wrapper handles all the logic for
    // encoding/decoding the PlayerState struct to/from UserDefaults.
    @UserDefault(key: "playerState", defaultValue: PlayerState.default)
    var playerState: PlayerState

    private init() {}
    
    func save(_ state: PlayerState) {
        self.playerState = state
    }

    func load() -> PlayerState {
        return self.playerState
    }
}

// MARK: - @UserDefault Property Wrapper

/// A generic property wrapper for saving/loading Codable types in UserDefaults.
@propertyWrapper
struct UserDefault<T: Codable> {
    let key: String
    let defaultValue: T
    let storage: UserDefaults

    init(key: String, defaultValue: T, storage: UserDefaults = .standard) {
        self.key = key
        self.defaultValue = defaultValue
        self.storage = storage
    }

    var wrappedValue: T {
        get {
            // Read and decode the data
            guard let data = storage.data(forKey: key) else {
                return defaultValue
            }
            let decoder = JSONDecoder()
            return (try? decoder.decode(T.self, from: data)) ?? defaultValue
        }
        set {
            // Encode and save the data
            let encoder = JSONEncoder()
            if let encodedData = try? encoder.encode(newValue) {
                storage.set(encodedData, forKey: key)
            }
        }
    }
}
//
//  GameScene.swift
//  BouncyBet
//
//  This is the heart of the game. It is an SKScene that
//  handles all physics, rendering, and game logic.
//

import SpriteKit

class GameScene: SKScene, SKPhysicsContactDelegate {
    
    // MARK: - Properties
    
    /// A weak reference back to the ViewModel for communication.
    weak var viewModel: GameViewModel?
    
    private var isRoundActive = false
    private var currentRoundScore = 0 {
        didSet {
            // Notify the ViewModel every time the score changes
            viewModel?.scoreDidChange(newScore: currentRoundScore)
        }
    }
    
    private var projectileNode: SKSpriteNode?
    private var launcherNode: SKSpriteNode!
    private var aimLine: SKShapeNode?
    private var powerLabel: SKLabelNode?
    
    private var placedObjects: [SKSpriteNode] = []
    
    // Drag gesture properties
    private var startTouch: CGPoint?
    private var currentTouch: CGPoint?
    private var isDragging = false
    
    // Trail effect
    private var trailNode: SKEmitterNode?
    
    // Overlay screens
    private var resultOverlay: SKNode?
    private var tutorialOverlay: SKNode?
    private var isShowingOverlay = false
    
    // MARK: - Scene Lifecycle
    
    override func didMove(to view: SKView) {
        super.didMove(to: view)
        
        backgroundColor = UIColor(red: 0.1, green: 0.1, blue: 0.2, alpha: 1.0)
        
        // 1. Set up the physics world - NO GRAVITY!
        physicsWorld.gravity = CGVector(dx: 0, dy: 0)  // Zero gravity
        physicsWorld.contactDelegate = self
        
        // 2. Create the world boundary
        let boundaryBody = SKPhysicsBody(edgeLoopFrom: self.frame)
        boundaryBody.categoryBitMask = PhysicsCategory.worldBoundary
        boundaryBody.restitution = 0.8 // Good bounce off walls
        self.physicsBody = boundaryBody
        
        // 3. Create the launcher (at bottom)
        launcherNode = SKSpriteNode(color: .cyan, size: CGSize(width: 60, height: 60))
        launcherNode.position = CGPoint(x: self.frame.midX, y: self.frame.minY + 100)
        launcherNode.zPosition = 10
        
        // Add a circular outline to the launcher
        let circle = SKShapeNode(circleOfRadius: 35)
        circle.strokeColor = .white
        circle.lineWidth = 3
        circle.fillColor = .clear
        circle.glowWidth = 2
        launcherNode.addChild(circle)
        
        addChild(launcherNode)
        
        // 4. Create power label
        powerLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
        powerLabel?.fontSize = 20
        powerLabel?.fontColor = .yellow
        powerLabel?.position = CGPoint(x: self.frame.midX, y: self.frame.minY + 180)
        powerLabel?.zPosition = 15
        powerLabel?.isHidden = true
        addChild(powerLabel!)
        
        // 5. Start with a fresh field
        prepareNewRound()
        
        // 6. Show tutorial overlay on first launch
        showTutorialOverlay()
    }
    
    // MARK: - Overlay Screens
    
    private func showTutorialOverlay() {
        isShowingOverlay = true
        
        tutorialOverlay = SKNode()
        tutorialOverlay?.zPosition = 100
        
        // Semi-transparent background
        let background = SKSpriteNode(color: UIColor.black.withAlphaComponent(0.8),
                                     size: self.size)
        background.position = CGPoint(x: self.frame.midX, y: self.frame.midY)
        tutorialOverlay?.addChild(background)
        
        // Title
        let title = SKLabelNode(fontNamed: "Helvetica-Bold")
        title.text = "HOW TO PLAY"
        title.fontSize = 36
        title.fontColor = .white
        title.position = CGPoint(x: self.frame.midX, y: self.frame.midY + 150)
        tutorialOverlay?.addChild(title)
        
        // Rules
        let rules = [
            "• Drag back from the launcher to aim",
            "• Release to shoot the ball",
            "• Blue circles: +10 points (bounce)",
            "• Yellow squares: +100 points (pass through)",
            "• Red squares: -50 points (pass through)",
            "• You have 10 seconds per round",
            "• Each round costs 10 coins"
        ]
        
        var yOffset: CGFloat = 50
        for rule in rules {
            let label = SKLabelNode(fontNamed: "Helvetica")
            label.text = rule
            label.fontSize = 18
            label.fontColor = .white
            label.horizontalAlignmentMode = .left
            label.position = CGPoint(x: self.frame.midX - 150, y: self.frame.midY + yOffset)
            tutorialOverlay?.addChild(label)
            yOffset -= 30
        }
        
        // Start button
        let buttonBg = SKSpriteNode(color: .green, size: CGSize(width: 200, height: 50))
        buttonBg.position = CGPoint(x: self.frame.midX, y: self.frame.midY - 150)
        buttonBg.name = "startButton"
        tutorialOverlay?.addChild(buttonBg)
        
        let buttonText = SKLabelNode(fontNamed: "Helvetica-Bold")
        buttonText.text = "START PLAYING"
        buttonText.fontSize = 20
        buttonText.fontColor = .white
        buttonText.verticalAlignmentMode = .center
        buttonText.position = CGPoint.zero
        buttonBg.addChild(buttonText)
        
        addChild(tutorialOverlay!)
    }
    
    private func showResultOverlay(score: Int, payout: Int) {
        isShowingOverlay = true
        
        resultOverlay = SKNode()
        resultOverlay?.zPosition = 100
        
        // Semi-transparent background
        let background = SKSpriteNode(color: UIColor.black.withAlphaComponent(0.7),
                                     size: self.size)
        background.position = CGPoint(x: self.frame.midX, y: self.frame.midY)
        resultOverlay?.addChild(background)
        
        // Result container
        let container = SKSpriteNode(color: UIColor.darkGray,
                                    size: CGSize(width: 300, height: 200))
        container.position = CGPoint(x: self.frame.midX, y: self.frame.midY)
        resultOverlay?.addChild(container)
        
        // Score label
        let scoreLabel = SKLabelNode(fontNamed: "Helvetica-Bold")
        scoreLabel.text = "ROUND COMPLETE!"
        scoreLabel.fontSize = 24
        scoreLabel.fontColor = .white
        scoreLabel.position = CGPoint(x: self.frame.midX, y: self.frame.midY + 50)
        resultOverlay?.addChild(scoreLabel)
        
        // Points label
        let pointsLabel = SKLabelNode(fontNamed: "Helvetica")
        pointsLabel.text = "Score: \(score) points"
        pointsLabel.fontSize = 20
        pointsLabel.fontColor = .yellow
        pointsLabel.position = CGPoint(x: self.frame.midX, y: self.frame.midY)
        resultOverlay?.addChild(pointsLabel)
        
        // Payout label
        let payoutLabel = SKLabelNode(fontNamed: "Helvetica")
        let netGain = payout - GameConfig.wagerAmount
        let gainText = netGain >= 0 ? "+\(netGain)" : "\(netGain)"
        payoutLabel.text = "Coins: \(gainText)"
        payoutLabel.fontSize = 20
        payoutLabel.fontColor = netGain >= 0 ? .green : .red
        payoutLabel.position = CGPoint(x: self.frame.midX, y: self.frame.midY - 50)
        resultOverlay?.addChild(payoutLabel)
        
        // Info text
        let infoLabel = SKLabelNode(fontNamed: "Helvetica")
        infoLabel.text = "Tap 'Enter Round' to continue"
        infoLabel.fontSize = 14
        infoLabel.fontColor = .lightGray
        infoLabel.position = CGPoint(x: self.frame.midX, y: self.frame.midY - 100)
        resultOverlay?.addChild(infoLabel)
        
        addChild(resultOverlay!)
    }
    
    func hideResultOverlay() {
        resultOverlay?.removeFromParent()
        resultOverlay = nil
        isShowingOverlay = false
    }
    
    // MARK: - Game Loop
    
    /// Called by the ViewModel to set up the field for a new round.
    func prepareNewRound() {
        // Hide result overlay if showing
        hideResultOverlay()
        
        // 1. Clear old objects
        for obj in placedObjects {
            obj.removeFromParent()
        }
        placedObjects.removeAll()
        
        // 2. Generate new field
        generateField(objectCount: 35)
        
        // 3. Reset state
        isRoundActive = false
        currentRoundScore = 0
    }
    
    /// Starts the 10-second round timer.
    private func startRoundTimer() {
        guard !isRoundActive else { return }
        
        isRoundActive = true
        
        let waitAction = SKAction.wait(forDuration: GameConfig.projectileLifespan)
        let endRoundAction = SKAction.run { [weak self] in
            self?.endRound()
        }
        
        let sequence = SKAction.sequence([waitAction, endRoundAction])
        self.run(sequence, withKey: "roundTimer")
    }
    
    /// Called by the timer when the round is over.
    private func endRound() {
        isRoundActive = false
        self.removeAction(forKey: "roundTimer")
        
        trailNode?.removeFromParent()
        trailNode = nil
        projectileNode?.removeFromParent()
        projectileNode = nil
        
        // Calculate payout
        let payout = currentRoundScore * GameConfig.payoutMultiplier
        
        // Show result overlay
        showResultOverlay(score: currentRoundScore, payout: payout)
        
        // Report final score back to ViewModel
        viewModel?.roundDidEnd(score: currentRoundScore)
    }
    
    // MARK: - Touch Handling
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard let touch = touches.first else { return }
        
        let location = touch.location(in: self)
        let nodes = self.nodes(at: location)
        
        // Check for tutorial start button
        if nodes.contains(where: { $0.name == "startButton" }) {
            tutorialOverlay?.removeFromParent()
            tutorialOverlay = nil
            isShowingOverlay = false
            return
        }
        
        // Don't allow interaction during overlays or active rounds
        guard !isShowingOverlay, !isRoundActive else { return }
        
        // Check if touch is near the launcher
        let distance = hypot(location.x - launcherNode.position.x,
                           location.y - launcherNode.position.y)
        
        if distance < 100 {
            isDragging = true
            startTouch = launcherNode.position
            currentTouch = location
            
            // Create aim line
            aimLine = SKShapeNode()
            aimLine?.strokeColor = UIColor(white: 1, alpha: 0.5)
            aimLine?.lineWidth = 3
            aimLine?.zPosition = 5
            addChild(aimLine!)
            
            // Show power label
            powerLabel?.isHidden = false
            
            updateAimLine()
        }
    }
    
    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard let touch = touches.first, isDragging, !isShowingOverlay else { return }
        
        currentTouch = touch.location(in: self)
        updateAimLine()
    }
    
    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
        guard isDragging, let start = startTouch, let current = currentTouch, !isShowingOverlay else {
            isDragging = false
            return
        }
        
        isDragging = false
        
        // Remove aim line
        aimLine?.removeFromParent()
        aimLine = nil
        powerLabel?.isHidden = true
        
        // Calculate pull vector (opposite direction)
        let pullVector = CGVector(dx: start.x - current.x,
                                 dy: start.y - current.y)
        
        // Limit maximum power
        let maxPower: CGFloat = 15.0
        let power = min(sqrt(pullVector.dx * pullVector.dx + pullVector.dy * pullVector.dy) / 10, maxPower)
        
        // Only shoot if pulled back enough
        if power > 1 {
            shootProjectile(direction: pullVector, power: power)
        }
        
        startTouch = nil
        currentTouch = nil
    }
    
    private func updateAimLine() {
        guard let start = startTouch, let current = currentTouch, let aimLine = aimLine else { return }
        
        // Create path for aim line
        let path = CGMutablePath()
        
        // Calculate trajectory preview
        let pullVector = CGVector(dx: start.x - current.x,
                             dy: start.y - current.y)
        
        // Show preview line in shooting direction
        let previewEnd = CGPoint(x: start.x + pullVector.dx * 2,
                            y: start.y + pullVector.dy * 2)
        
        path.move(to: start)
        path.addLine(to: previewEnd)
        aimLine.path = path
        
        // Update power label
        let power = min(sqrt(pullVector.dx * pullVector.dx + pullVector.dy * pullVector.dy) / 10, 15)
        powerLabel?.text = String(format: "Power: %.0f%%", power * 100 / 15)
    }
    
    private func shootProjectile(direction: CGVector, power: CGFloat) {
        // 1. Create the projectile
        projectileNode = SKSpriteNode(color: .white, size: CGSize(width: 12, height: 12))
        projectileNode?.position = launcherNode.position
        projectileNode?.zPosition = 8
        
        // 2. Create trail effect
        let trail = SKEmitterNode()
        trail.particleTexture = SKTexture(imageNamed: "spark")
        trail.particleLifetime = 0.5
        trail.particleLifetimeRange = 0.2
        trail.particleScale = 0.2
        trail.particleScaleRange = 0.1
        trail.particleAlpha = 0.8
        trail.particleAlphaSpeed = -2
        trail.particleColor = .cyan
        trail.particleColorBlendFactor = 1
        trail.particleBlendMode = .add
        trail.particleBirthRate = 100
        trail.emissionAngle = .pi
        trail.particleSpeed = 50
        trail.particleSpeedRange = 20
        trail.targetNode = self
        trail.zPosition = 7
        
        trailNode = trail
        projectileNode?.addChild(trail)
        
        // 3. Create physics body
        let body = SKPhysicsBody(circleOfRadius: 6)
        body.isDynamic = true
        body.categoryBitMask = PhysicsCategory.projectile
        body.collisionBitMask = PhysicsCategory.obstacle | PhysicsCategory.worldBoundary
        body.contactTestBitMask = PhysicsCategory.obstacle | PhysicsCategory.reward | PhysicsCategory.hazard
        
        // Physics properties for no-gravity environment
        body.restitution = 0.95  // Very bouncy
        body.linearDamping = 0.02  // Very low damping (keeps moving)
        body.angularDamping = 0.1
        body.friction = 0
        body.mass = 0.05
        body.usesPreciseCollisionDetection = true
        body.affectedByGravity = false  // Explicitly no gravity
        
        projectileNode?.physicsBody = body
        addChild(projectileNode!)
        
        // 4. Apply velocity based on drag
        let velocity = CGVector(dx: direction.dx * power,
                               dy: direction.dy * power)
        body.velocity = velocity
        
        // 5. Start timer
        startRoundTimer()
    }
    
    // MARK: - Object Generation
    
    private func generateField(objectCount: Int) {
        // MOVED HIGHER UP - field is now in the upper portion of screen
        let playableRect = CGRect(x: 30,
                                y: self.frame.midY,  // Start from middle
                                width: self.frame.width - 60,
                                height: self.frame.height / 2 - 50)  // Use upper half
        
        // Generate balanced objects (equal good/bad)
        var objectsToPlace: [ObjectData] = []
        
        // Add specific number of each type for balance
        let obstacleCount = objectCount / 2  // 50%
        let rewardCount = objectCount / 4     // 25%
        let hazardCount = objectCount / 4     // 25%
        
        for _ in 0..<obstacleCount {
            objectsToPlace.append(ObjectData(type: .obstacle,
                                           points: GameConfig.obstaclePoints,
                                           textureName: "obstacle"))
        }
        
        for _ in 0..<rewardCount {
            objectsToPlace.append(ObjectData(type: .reward,
                                           points: GameConfig.rewardPoints,
                                           textureName: "reward"))
        }
        
        for _ in 0..<hazardCount {
            objectsToPlace.append(ObjectData(type: .hazard,
                                           points: GameConfig.hazardPoints,
                                           textureName: "hazard"))
        }
        
        // Shuffle for random placement
        objectsToPlace.shuffle()
        
        for data in objectsToPlace {
            let node = createNode(from: data)
            
            var attempts = 0
            while attempts < 100 {
                let randomX = CGFloat.random(in: playableRect.minX...playableRect.maxX)
                let randomY = CGFloat.random(in: playableRect.minY...playableRect.maxY)
                node.position = CGPoint(x: randomX, y: randomY)
                
                var intersects = false
                for existingNode in placedObjects {
                    if node.intersects(existingNode) {
                        intersects = true
                        break
                    }
                }
                
                if !intersects {
                    break
                }
                attempts += 1
            }
            
            addChild(node)
            placedObjects.append(node)
        }
    }
    
    private func createNode(from data: ObjectData) -> SKSpriteNode {
        let size: CGSize
        let color: SKColor
        let category: UInt32
        
        switch data.type {
        case .obstacle:
            size = CGSize(width: 25, height: 25)
            color = UIColor(red: 0.3, green: 0.6, blue: 1.0, alpha: 1.0)
            category = PhysicsCategory.obstacle
        case .reward:
            size = CGSize(width: 30, height: 30)
            color = UIColor(red: 1.0, green: 0.8, blue: 0.2, alpha: 1.0)
            category = PhysicsCategory.reward
        case .hazard:
            size = CGSize(width: 30, height: 30)  // Same size as reward
            color = UIColor(red: 1.0, green: 0.3, blue: 0.3, alpha: 1.0)
            category = PhysicsCategory.hazard
        }
        
        let node = SKSpriteNode(color: color, size: size)
        node.name = data.id.uuidString
        
        // Add visual effects based on type
        if data.type == .reward {
            // Add pulsing animation to rewards
            let scaleUp = SKAction.scale(to: 1.2, duration: 0.5)
            let scaleDown = SKAction.scale(to: 1.0, duration: 0.5)
            let pulse = SKAction.sequence([scaleUp, scaleDown])
            node.run(SKAction.repeatForever(pulse))
        } else if data.type == .hazard {
            // Add rotation to hazards
            let rotate = SKAction.rotate(byAngle: .pi * 2, duration: 3)
            node.run(SKAction.repeatForever(rotate))
        }
        
        node.userData = ["points": data.points]
        
        let body = SKPhysicsBody(circleOfRadius: size.width / 2)
        body.isDynamic = false
        body.categoryBitMask = category
        body.affectedByGravity = false
        
        if data.type == .obstacle {
            body.restitution = 1.0
        }
        
        node.physicsBody = body
        return node
    }
    
    // MARK: - Collision Handling
    
    func didBegin(_ contact: SKPhysicsContact) {
        let bodyA: SKPhysicsBody
        let bodyB: SKPhysicsBody
        if contact.bodyA.categoryBitMask < contact.bodyB.categoryBitMask {
            bodyA = contact.bodyA
            bodyB = contact.bodyB
        } else {
            bodyA = contact.bodyB
            bodyB = contact.bodyA
        }

        guard bodyA.categoryBitMask == PhysicsCategory.projectile else { return }
        
        let otherNode = bodyB.node
        
        if let points = otherNode?.userData?["points"] as? Int {
            currentRoundScore += points
            
            // Visual feedback for scoring
            if let node = otherNode {
                let flash = SKAction.sequence([
                    SKAction.fadeAlpha(to: 0.3, duration: 0.1),
                    SKAction.fadeAlpha(to: 1.0, duration: 0.1)
                ])
                node.run(flash)
            }
        }
        
        if bodyB.categoryBitMask == PhysicsCategory.reward || bodyB.categoryBitMask == PhysicsCategory.hazard {
            otherNode?.removeFromParent()
        }
    }
}
//
//  GameViewModel.swift
//  BouncyBet
//
//  This class is the "single source of truth" for the application.
//  It's an ObservableObject, so SwiftUI views can subscribe to its changes.
//  It bridges the gap between the SwiftUI UI and the SpriteKit GameScene.
//

import Foundation
import SpriteKit
import Combine  // ADD THIS IMPORT

class GameViewModel: ObservableObject {
    
    // MARK: - Published Properties
    // SwiftUI views will automatically update when these change.
    
    @Published var playerState: PlayerState
    @Published var isRoundActive: Bool = false
    @Published var currentRoundScore: Int = 0
    
    // MARK: - Properties
    
    /// A reference to the SpriteKit scene.
    let gameScene: GameScene

    // MARK: - Initializer
    
    init() {
        // 1. Load the player's saved state
        let loadedState = PersistenceManager.shared.load()
        self.playerState = loadedState
        
        // 2. Create the GameScene
        // We set the size here (e.g., iPhone 14 Pro)
        // .aspectFill will scale it to other devices.
        self.gameScene = GameScene(size: CGSize(width: 393, height: 852))
        self.gameScene.scaleMode = .aspectFill
        
        // 3. CRITICAL: Pass a reference of this ViewModel TO the GameScene.
        // This is the "delegate" pattern that allows the scene to call
        // methods on the ViewModel (e.g., roundDidEnd).
        self.gameScene.viewModel = self
    }
    
    func startNewRound() {
        gameScene.hideResultOverlay()
        placeWager()
    }
    
    // MARK: - Intents (Methods called by UI)
    
    /// Called by the SwiftUI "Enter Round" button.
    func placeWager() {
        guard playerState.coins >= GameConfig.wagerAmount, !isRoundActive else {
            return // Not enough coins, or round already in progress
        }
        
        // 1. Deduct the wager
        playerState.coins -= GameConfig.wagerAmount
        
        // 2. Update state
        isRoundActive = true
        currentRoundScore = 0
        
        // 3. Tell the GameScene to set up the new field
        gameScene.prepareNewRound()
    }
    
    // MARK: - Callbacks (Methods called by GameScene)
    
    /// Called by the GameScene when the 10-second timer expires.
    func roundDidEnd(score: Int) {
        // 1. Calculate payout
        let payout = score * GameConfig.payoutMultiplier
        
        // 2. Add payout to total
        playerState.coins += payout
        
        // 3. Check for high score
        if score > playerState.highScore {
            playerState.highScore = score
        }
        
        // 4. Update state
        isRoundActive = false
        currentRoundScore = score
        
        // 5. Save the new player state to disk
        PersistenceManager.shared.save(playerState)
    }
    
    /// Called by the GameScene on every collision to update the UI in real-time.
    func scoreDidChange(newScore: Int) {
        // Use `DispatchQueue.main.async` because this is called
        // from the SpriteKit physics loop (a background thread).
        // UI updates MUST happen on the main thread.
        DispatchQueue.main.async {
            self.currentRoundScore = newScore
        }
    }
}

// A helper extension for the view
extension GameViewModel {
    var canAffordWager: Bool {
        playerState.coins >= GameConfig.wagerAmount
    }
}
//
//  ContentView.swift
//  BouncyBet
//
//  This is the main SwiftUI view. It hosts the SpriteView
//  and overlays the UI on top of it.
//

import SwiftUI
import SpriteKit
import Combine  // ADD THIS IMPORT (optional but good practice)

struct ContentView: View {
    
    // 1. Creates the ViewModel, the app's "source of truth".
    //    @StateObject ensures it lives for the life of the view.
    @StateObject private var viewModel = GameViewModel()

    var body: some View {
        ZStack {
            
            // 2. The SpriteKit game scene, hosted in SwiftUI.
            //    It fills the entire background.
            SpriteView(scene: viewModel.gameScene)
                .ignoresSafeArea()
            
            // 3. The SwiftUI UI overlay
            VStack {
                HStack {
                    Text("Coins: \(viewModel.playerState.coins)")
                        .font(.title2)
                        .fontWeight(.bold)
                        .padding(12)
                        .background(.black.opacity(0.5))
                        .cornerRadius(10)
                    
                    Spacer()
                    
                    Text("High Score: \(viewModel.playerState.highScore)")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .padding(12)
                        .background(.black.opacity(0.5))
                        .cornerRadius(10)
                }
                .padding()
                .foregroundColor(.white)
                
                Spacer()
                
                // 4. The bottom UI section changes based on game state.
                if viewModel.isRoundActive {
                    // Show the current score during the round
                    Text("Score: \(viewModel.currentRoundScore)")
                        .font(.largeTitle)
                        .fontWeight(.heavy)
                        .foregroundColor(.white)
                        .padding()
                        .background(.black.opacity(0.5))
                        .cornerRadius(15)
                } else {
                    // Show the "Enter Round" button when idle
                    Button(action: viewModel.placeWager) {
                        Text("Enter Round (\(GameConfig.wagerAmount) Coins)")
                            .font(.headline)
                            .fontWeight(.bold)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(viewModel.canAffordWager ? Color.blue : Color.gray)
                            .foregroundColor(.white)
                            .cornerRadius(10)
                    }
                    .disabled(!viewModel.canAffordWager) // Disable if not enough coins
                    .padding()
                }
            }
        }
    }
}
